해시테이블은 key와 value의 형태를 가지고 있는 자료구조이죠.
key값을 통해 value에 접근하는 해시테이블은 데이터를 넣고자 할 때 Add("키값","데이터") 메소드로 
값을 넣어주는데요. Add 시 키 값을 '해싱'하여 Dictionary 생성 시 함께 생성된 배열에 값이 들어갈 'index'를
지정해주고, 해당 index(해싱된 key)에 데이터를 삽입합니다!
해싱에 대해서 말씀드리자면 Dictionary 에서 Add 메소드 호출 시 전달 받은 key 값을
자료형에 상관 없이 C#의 기본제공 메소드인  GetHashCode() 를 사용해 int 형으로 변환 합니다.
(C# 에선 해싱 작업에 SHA-1 해시 함수를 사용합니다)
변환 된 int 형의 index 는 데이터들이 담길 배열의 크기보다 '작아야'하기 때문에 나눗셈법을 사용하며
그렇게 조정된 index 가 음수일 경우를 대비하여 Math.Abs 메소드를 이용해 절대값으로 최종적으로 index를 조정합니다.

key 값으로 데이터에 접근한다는 특성 덕에 해시테이블의 시간복잡도는 평균적으로 O(1) 이지만 해시테이블의 고질적인 문제점으로는 
해시테이블의 충돌이 있겠는데요. 다른 키 값이라고 하더라도 해싱함수가 호출되어 해싱이 이뤄진 과정에서 
key값은 다르지만 index는 같은 값이 나올 수 있다는 것이죠.
이러한 해시테이블의 충돌에 있어 해결방안에는 '체이닝'과 '개방주소법'이 있습니다.

체이닝은 연결리스트를 사용하여 해당 위치에서
값을 찾아내는 방법인데요. 위 방법을 사용할 경우
잦은 GC호출이 우려되며 C#에선 권장하는 방법은 아닙니다.

c#에서 사용하고 있는 충돌해결 방안은 
열린주소법이라는 방식인데요. index의 위치에 이미 데이터가 존재한다면 그 다음 위치에 값을 부여하는 방식입니다.
방금 말씀드린대로 그 다음 위치에 값을 부여하는 선형방식 외에도 제곱탐색, 이중해시 등 다양한 빈자리 찾기 법이 존재합니다.

이 방법은 체이닝과 다르게 추가적인 저장공간은 필요하지 않고
삽입 삭제에 있어서 오버헤드가 적은것이 특징이죠.
단.. 헤시테이블 내에 자료가 많아질수록 성능저하가 발생한다는 것
그리고 테이블 내에 공간 사용률이 높아도 성능저하가 발생한다는 것도 단점이라 이럴 경우엔 재해싱을 통해서
해시테이블의 크기를 더 크게 늘려서 테이블 내의 모든 데이터를 더 커진 해시테이블로 복사, 그리고 해싱하는 작업을 해야합니다. 

이 작업도 메모리 효율이 떨어지는 작업이라 해시테이블의 데이터가 담길 배열의 크기가 클 수록 위 단점들이 발생하지 않을 가능성이 크다고 볼 수 있겠습니다.