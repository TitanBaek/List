namespace _08_HashTable
{
    internal class Program
    {
        /******************************************************
		 * 해시테이블 (HashTable)
		 * 
		 * [키 값을 해시함수로 해싱하여 해시테이블의 특정 위치(인덱스)로 직접 엑세스하도록 만든 방식]
		 * 
		 * 해시 : 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑
		 * 
		 * 키 값을 해시함수를 통해 Index화 하여 해당 위치에 데이터를 저장하고
		 * 데이터를 불러올때도 키 값을 해시함수를 통해 Index화 하여 해당 위치의 데이터를 꺼낸다.
		 * 주의 사항으로는 입력된 키 값이 해시함수를 돌렸을때 동일한 값이 나와야함
         ******************************************************/

        // <해시함수의 조건>
        // 1. 입력에 대한 해시함수의 결과가 항상 동일한 값이어야 한다.


        // <해시함수의 효율>
        // 1. 해시함수 자체가 느린경우 해시테이블을 사용하는 의미가 없다.
        // 2. 해시 충돌이 일어날수록.. 선형탐사가 이뤄지기 때문에 효율이 떨어짐..
        // 3. 그렇기에 해쉬함수의 결과가 밀집도가 낮아야함.
        // 4. 해쉬테이블의 크기가 클 수록 효율이 높다. (공간이 넓다 = 겹침이 적다)


        // <해시테이블 주의점 - 충돌>
        // 해시함수가 서로 다른 입력 값에 대해 동일한 해시테이블 주소를 반환하는 것
        // 모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음
        // 대표적인 충돌 해결방안으로 체이닝과 개방주소법이 있음

        // 체이닝 : 인덱스 충돌이 일어났을때 링크드리스트를 사용하여 해당 위치에서 값을 찾아내는 것.
        // C#에서는 노드기반인 체이닝을 쓰고 있지는 않습니다..

        // 개방주소법(열린주소법)
        // C#은 열린 주소법을 씀
        // 값을 넣고자하는 index 위치에 이미 값이 존재한다면
        // 그 다음 위치에 값을 부여하는 방식


        // <충돌해결방안 - 체이닝>
        // 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식
        // 장점 : 해시테이블에 자료가 많아지더라도 성능저하가 적음
        // 단점 : 해시테이블 외 추가적인 저장공간이 필요

        // <충돌해결방안 - 개방주소법>
        // 해시 충돌이 발생하면 다른 빈 공간에 데이터를 삽입하는 방식
        // 해시 충돌시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정
        // 장점 : 추가적인 저장공간이 필요하지 않음, 삽입삭제시 오버헤드가 적음
        // 단점 : 해시테이블에 자료가 많아질수록 성능저하가 많음
        // 해시테이블의 공간 사용률이 높을 경우 성능저하가 발생하므로 재해싱 과정을 진행함
        // 재해싱 : 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱 

        static void Dictionary()
        {
            Dictionary<string,Item> dictionary = new Dictionary<string,Item>();

            dictionary.Add("초기무기", new Item("초보자용 방어구", 20));
            dictionary.Add("초기방어구", new Item("초보자용 무기", 15));
            dictionary.Add("초기아이템", new Item("체력포션", 5));

            Console.WriteLine(dictionary["초기아이템"].name);

            dictionary.Remove("초기방어구");

            if (dictionary.ContainsKey("초기방어구"))                                        // 키 값의 여부를 bool로 반환해주는 메소드
            {
                Console.WriteLine("있습니다. 초기방어구");
            }
            else
            {
                Console.WriteLine("없습니다. 초기방어구");
            }


        }

        static void Main(string[] args)
        {
            Dictionary();
        }

        public class Item
        {
            public string name;
            public int weight;

            public Item(string name,int weight) { 
                this.name = name;
                this.weight = weight;
            }
        }
    }
}